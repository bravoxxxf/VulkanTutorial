本章将首先介绍Vulkan及其解决的问题。之后，我们将研究构成第一个三角形所需的要素。这将为你提供一个整体的视野，以便理解后续章节的内容。最后，我们将介绍Vulkan API的结构和常见的使用模式。

## Vulkan的起源

与之前的图形API一样，Vulkan被设计为一个跨平台的抽象层，用于操作[图形处理单元（GPU）](https://en.wikipedia.org/wiki/Graphics_processing_unit)。大多数这些API的问题在于它们设计时的时代主要侧重于可配置的固定功能图形硬件。程序员必须以标准格式提供顶点数据，并受制于GPU制造商在光照和着色选项方面的限制。

随着图形卡架构的发展，它们开始提供越来越多的可编程功能。所有这些新功能都必须以某种方式与现有的API集成。这导致了不太理想的抽象层，并且在图形驱动程序方面需要进行很多猜测，以将程序员的意图映射到现代图形架构上。这就是为什么有那么多驱动程序更新来提高游戏性能，有时提升幅度相当大。由于这些驱动程序的复杂性，应用程序开发人员还需要处理不同供应商之间的不一致性，比如[着色器（shaders）](https://en.wikipedia.org/wiki/Shader)语法。除了这些新功能外，过去十年还出现了大量配备强大图形硬件的移动设备。这些移动GPU根据能量和空间需求具有不同的架构。其中一个例子是[切片渲染（tiled rendering）](https://en.wikipedia.org/wiki/Tiled_rendering)，通过提供更多对此功能的控制，可以改善性能。这些API时代的另一个限制是有限的多线程支持，这可能会导致CPU方面的瓶颈问题。

Vulkan通过从头开始为现代图形架构设计，解决了这些问题。它通过使用更详细的API，使程序员能够清晰地指定其意图，从而减少了驱动程序的开销，并允许多个线程并行创建和提交命令。它通过切换到使用单一编译器的标准化字节码格式，减少了着色器编译方面的不一致性。最后，它将现代图形卡的通用处理能力纳入考虑，将图形和计算功能统一到一个API中。

## 绘制三角形所需的步骤

现在，我们将概述在一个良好运作的Vulkan程序中绘制一个三角形所需的所有步骤。这里介绍的所有概念将在接下来的章节中详细阐述。这只是为了让你对各个组件有一个整体的认识。

### 第一步 - 实例和物理设备选择

一个Vulkan应用程序通过创建一个`VkInstance`来设置Vulkan API。实例是通过描述你的应用程序和任何将要使用的API扩展来创建的。创建实例后，你可以查询支持Vulkan的硬件，并选择一个或多个`VkPhysicalDevice`用于操作。你可以查询属性，如VRAM大小和设备能力，以选择所需的设备，例如优先使用专用的显卡。

### 第二步 - 逻辑设备和队列族

在选择要使用的正确硬件设备之后，你需要创建一个VkDevice（逻辑设备），其中你需要更具体地描述你将使用的VkPhysicalDeviceFeatures，如多视口渲染和64位浮点数。你还需要指定要使用的队列族。大多数使用Vulkan进行的操作，如绘制命令和内存操作，都是通过将它们提交到VkQueue中异步执行的。队列是从队列族中分配的，每个队列族在其队列中支持一组特定的操作。例如，可以为图形、计算和内存传输操作设置不同的队列族。队列族的可用性也可以作为物理设备选择的一个区分因素。一个支持Vulkan的设备可能不提供任何图形功能，但是今天所有支持Vulkan的显卡通常都支持我们感兴趣的所有队列操作。

### 第三步 - 窗口表面和交换链

除非你只对离屏渲染感兴趣，否则你需要创建一个窗口来呈现渲染后的图像。窗口可以使用本地平台的API或类库（如[GLFW](http://www.glfw.org/)和[SDL](https://www.libsdl.org/)）来创建。在本教程中，我们将使用GLFW，但关于这个我们会在下一章详细介绍。

实际上渲染到窗口需要两个组件：窗口表面（VkSurfaceKHR）和交换链（VkSwapchainKHR）。注意`KHR`后缀，这意味着这些对象是Vulkan扩展的一部分。Vulkan API本身完全与平台无关，这就是为什么我们需要使用标准化的WSI（Window System Interface）扩展与窗口管理器进行交互。表面是一个跨平台的抽象，用于渲染到窗口，并且通常通过提供本地窗口句柄的引用来实例化，例如在Windows上是`HWND`。幸运的是，GLFW库有一个内置函数来处理这个平台特定的细节。

交换链是一组渲染目标。它的基本目的是确保我们当前渲染的图像与当前显示在屏幕上的图像不同。这是为了确保只显示完整的图像。每次我们想要绘制一帧时，我们都需要向交换链请求一个图像来进行渲染。当我们完成一帧的绘制后，图像会被返回给交换链，在某个时刻呈现到屏幕上。渲染目标的数量和将完成的图像呈现到屏幕上的条件取决于呈现模式。常见的呈现模式有双缓冲（垂直同步）和三缓冲。我们将在交换链创建章节中详细讨论这些内容。

一些平台允许你通过`VK_KHR_display`和`VK_KHR_display_swapchain`扩展直接将图像渲染到显示器，而无需通过任何窗口管理器进行交互。这些扩展允许你创建一个表示整个屏幕的表面，并且可以用于实现自己的窗口管理器，例如。

### 第四步 - 图像视图和帧缓冲

为了对从交换链获取的图像进行绘制，我们需要将其包装到VkImageView和VkFramebuffer中。图像视图引用要使用的图像的特定部分，帧缓冲引用了用于颜色、深度和模板目标的图像视图。由于交换链中可能有许多不同的图像，我们会预先为每个图像创建一个图像视图和帧缓冲，并在绘制时选择正确的图像视图和帧缓冲。

### 第五步 - 渲染通道

Vulkan 中的渲染通道描述了渲染操作期间使用的图像类型、如何使用它们以及如何处理其内容。在我们最初的三角形渲染应用程序中，我们将告诉 Vulkan 我们将使用单个图像作为颜色目标，并且我们希望在绘制操作之前将其清除为纯色。渲染通道仅描述图像类型，而 VkFramebuffer 实际上将特定图像绑定到这些插槽。

### 第六步 - 图形管线

在Vulkan中，图形管线通过创建一个VkPipeline对象来设置。它描述了图形卡的可配置状态，如视口大小、深度缓冲操作以及使用VkShaderModule对象的可编程状态。VkShaderModule对象是从着色器字节码创建的。此外，图形管线还需要指定使用哪些渲染目标，这是通过引用渲染通道来完成的。

与现有的API相比，Vulkan最显著的特点之一是几乎所有的图形管线配置都需要事先设置。这意味着如果你想切换到不同的着色器或稍微改变顶点布局，那么你需要完全重新创建图形管线。这意味着你需要提前为所有不同的组合创建许多VkPipeline对象，以满足你的渲染操作需求。只有一些基本的配置，如视口大小和清除颜色，可以在运行时动态改变。所有的状态也都需要显式地描述，例如没有默认的颜色混合状态。

好消息是，因为你在进行提前编译而不是即时编译，所以对于驱动程序来说有更多的优化机会，而且运行时性能更可预测，因为像切换到不同的图形管线这样的大型状态改变是非常明确的。

### 第七步 - 命令池和命令缓冲

如前所述，我们想要执行的许多Vulkan操作，例如绘制操作，需要提交到一个队列中。这些操作首先需要记录到一个VkCommandBuffer中，然后才能提交。这些命令缓冲是从与特定队列族相关联的`VkCommandPool`中分配的。为了绘制一个简单的三角形，我们需要记录一个包含以下操作的命令缓冲：

* 开始渲染通道
* 绑定图形管线
* 绘制3个顶点
* 结束渲染通道

由于帧缓冲中的图像取决于交换链提供的具体图像，因此我们需要为每个可能的图像记录一个命令缓冲，并在绘制时选择正确的命令缓冲。另一种方法是在每帧重新记录命令缓冲，但这样效率不高。

### 第八步 - 主循环

现在绘制命令已经被包装到命令缓冲中，主循环就变得非常简单了。首先，我们使用vkAcquireNextImageKHR从交换链获取一张图像。然后，我们可以为该图像选择合适的命令缓冲，并使用vkQueueSubmit执行它。最后，我们将图像返回给交换链，以便通过vkQueuePresentKHR呈现到屏幕上。

提交到队列的操作是异步执行的。因此，我们必须使用信号量等同步对象来确保正确的执行顺序。绘制命令缓冲区的执行必须设置为等待图像采集完成，否则可能会出现我们开始渲染仍在读取以在屏幕上呈现的图像的情况。而vkQueuePresentKHR调用则需要等待渲染完成，我们将使用第二个信号量，在渲染完成后进行信号传递。

### 总结

这个简要的概览应该让你对绘制第一个三角形的工作有一个基本的理解。一个真实的程序包含更多的步骤，比如分配顶点缓冲区、创建统一缓冲区和上传纹理图像，这些将在接下来的章节中介绍。但我们会从简单开始，因为Vulkan本身的学习曲线已经足够陡峭。请注意，初始时我们将通过将顶点坐标嵌入顶点着色器中来取巧，而不是使用顶点缓冲区。这是因为管理顶点缓冲区需要对命令缓冲区有一定的了解。

简而言之，绘制第一个三角形的步骤如下：

* 创建VkInstance
* 选择支持的图形卡（VkPhysicalDevice）
* 创建用于绘制和呈现的VkDevice和VkQueue
* 创建窗口、窗口表面和交换链
* 将交换链图像包装为VkImageView
* 创建描述渲染目标和使用方式的渲染通道
* 为渲染通道创建帧缓冲
* 设置图形管线
* 为每个可能的交换链图像分配和记录包含绘制命令的命令缓冲
* 通过获取图像、提交正确的绘制命令缓冲和将图像返回给交换链来绘制帧

确实，这些步骤很多，但每个步骤的目的在接下来的章节中将被简化和清晰地解释。如果你对单个步骤与整个程序之间的关系感到困惑，可以回顾本章进行参考。

## API概念

本章将以对Vulkan API在较低级别上的结构进行简要概述。

### 编码规范

所有的Vulkan函数、枚举和结构体都在`vulkan.h`头文件中定义，该头文件包含在由LunarG开发的[Vulkan SDK](https://lunarg.com/vulkan-sdk/)中。我们将在下一章中介绍如何安装该SDK。

函数具有小写的`vk`前缀，枚举和结构体类型具有`Vk`前缀，枚举值具有`VK_`前缀。该API大量使用结构体来为函数提供参数。例如，对象的创建通常遵循以下模式：

```c++
VkXXXCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if (vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS) {
    std::cerr << "failed to create object" << std::endl;
    return false;
}
```

许多Vulkan中的结构需要你明确在成员变量中`sType`描述。`pNext`可以指向一个扩展结构，在本教程中始终为`nullptr`。创建或销毁对象的函数将具有一个`VkAllocationCallbacks`参数，允许你使用自定义分配器来管理驱动程序内存，在本教程中也将保持为`nullptr`。

几乎所有函数都返回一个VkResult，该结果要么是`VK_SUCCESS`，要么是一个错误代码。规范描述了每个函数可以返回哪些错误代码以及它们的含义。

### Validation layers

正如前面提到的，Vulkan被设计用于高性能和低驱动程序开销。因此，默认情况下，它的错误检查和调试功能非常有限。如果你做了错误的操作，驱动程序通常会崩溃而不是返回错误代码，或者更糟糕的是，在你的显卡上可能看起来正常工作，但在其他显卡上完全失败。

正如你所提到的，Vulkan允许通过验证层来启用详尽的检查。验证层是一些代码片段，可以插入在API和图形驱动程序之间，用于执行额外的参数检查和跟踪内存管理问题等操作。好处是你可以在开发过程中启用它们，然后在发布应用程序时完全禁用它们，以避免额外的开销。任何人都可以编写自己的验证层，但由LunarG提供的Vulkan SDK提供了一组标准的验证层，我们将在本教程中使用它们。你还需要注册一个回调函数来接收来自验证层的调试消息。

因为Vulkan在每个操作上都非常明确，并且验证层非常全面，所以相比于OpenGL和Direct3D，找出为什么屏幕是黑的问题实际上会更容易！

在我们开始编写代码之前，只剩下最后一步了，那就是[设置开发环境](!zh/Development_environment)。